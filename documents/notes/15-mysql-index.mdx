---
id: 15
title: 8.2 인덱스란?
date: 2024-03-23
tags:
  - Real MySQL
---

## 비유로 알아보는 인덱스의 특성 🔍

### 1. 책 맨 끝에 있는 찾아보기

책의 마지막에는 찾아보기라는 사전같은 것이 있다.
흔히들 이것을 인덱스에 비유한다. 그리고 이것의 중요한 특징은 바로 **정렬**이 되어있다는 것이다.
최대한 빨리 찾아갈 수 있게 'ㄱ', 'ㄴ', 'ㄷ'... 순서로 정렬돼있다.

DBMS의 인덱스도 마찬가지로 칼럼의 값을 주어진 순서로 미리 **정렬**해서 보관한다.

### 2. SortedList

SortedList 와 ArrayList 자료 구조는 다르다.

SortedList는 DBMS 의 인덱스와 같은 자료구조라면,
ArrayList는 DBMS의 원본 데이터파일과 같은 자료구조라고 생각할 수 있다.

원본데이터는 값이 저장되는 순서 그대로 유지되기 때문에 ArrayList에 비유할 수 있게 된다.
반면에 인덱스는 새로 값이 추가돼도 항상 정렬을 유지한다.

### SortedList 좀 더 들여다 보기 🤓

SortedList의 장단점

- 단: 데이터 저장의 시간복잡도가 크다. (정렬 유지)
- 장: 데이터 조회 시간복잡도가 작다. (정렬)

DBMS도 똑같이 적용된다.

- 단: insert, update, delete 문장 처리가 느려진다.
- 장: select가 빨라진다.

## 정리하기

DMBS의 인덱스는 저장 성능을 희생하고 데이터의 읽기 속도를 높이는 기능이다.

따라서 인덱스를 도입하기 전에 반드시 데이터의 저장속도를 어디까지 희생할 수 있는지,
읽기 속도를 얼마나 더 빠르게 만들기 위함인지 고민해야한다.

인덱스를 남발하면, 인덱스 데이터가 비대해져 역효과가 커질 수있다.

## 인덱스 분류

### 역할별

- Primary index: PK의 동치. 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스, NULL과 중복이 허용되지 않음
- Secondary index: PK 제외 모든 인덱스.

### 저장 방식 별

- B-Tree 인덱스: 가장 일반적으로 쓰이는 알고리즘. 역사가 깊어 성숙함. 컬럼 값을 변형하지 않고 원래의 값을 이용해 인덱싱.
  R-Tree 인덱스는 B-Tree 인덱스의 응용 알고리즘이다.
- Hash 인덱스: 컬럼의 해시를 인덱싱하는 알고리즘 -> 매우 빠른 검색을 지원
  하지만 값을 변형하므로 prefix 일치 같은 값의 일부 검색 + 범위 검색에 사용할 수 없음.
  메모리 기반 데이터베이스에서 많이 사용한다. 

### 데이터 중복 여부

- Unique index
- Non-unique index

유니크 여부는 옵티마이저에게 상당히 중요한 문제다.

유니크 인덱스에 대해 동등조건으로 검색한다는 것은 항상 1건의 레코드만 찾으면 된다는 것을 옵테마이저가 알수있다.
또한 인덱스 + 쿼리 실행계획을 볼 때 유니크인덱스로 인해 MySQL의 처리 방식이 천차만별인 것을 확인해볼 것이다!

이 외에도 전문 검색용 인덱스, 공간 검색용 인덱스 등이 있다.
