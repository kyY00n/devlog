---
id: 16
title: 8.3 B-Tree 인덱스
date: 2024-03-23
tags:
  - Real MySQL
---

B-Tree 인덱스?

Balanced Tree 를 의미한다.
B-Tree는 데이터베이스 인덱싱 알고리즘 가운데 가장 일반적으로 사용됨.

B-Tree에는 여러 변형 알고리즘이 있는데, 일반적으로 DBMS에서는 주로 B+트리 또는 B\*Tree 가 사용된다.
b트리는 앞서 말했듯 컬럼의 값을 변형하지 않고 항상 정렬된 상태로 유지한다.

전문검색이 아닌 경우 대부분 b트리로 커버할 수 있다.

# 8.3.1 구조 및 특성

b-tree 인덱스의 기본적인 구조를 알아보자! 😘

b-tree는 트리구조의 그림이다.

![240324-001113](/posts/16-mysql.indxe/240324-001113.png)

인덱스의 키값은 모두 정렬돼있지만, 데이터 파일의 레코드는 정렬돼있지 않은 것을 알 수 있다. (화살표 방향이 중구난방)

B-tree 인덱스 노드는 다음과 같이 생겼당. (InnoDB 기준, MyISAM은 다름)

![240324-002153](/posts/16-mysql.indxe/240324-002153.png)


b트리 리프노드에는 데이터파일에 접근할 수 있는 프라이머리키가 있다.
따라서 해당 PK정보로 Primary Key 인덱스를 타고 또 다시 리프노드로 도달하면, 그 때 레코드 정보에 도달할 수 있게 된다.

![240324-002206](/posts/16-mysql.indxe/240324-002206.png)

그리고 그림에서는 세컨더리 인덱스(이름) 을 통해 레코드에 접근하려고 하고 있는데,
InnoDB에서는 세컨더리 인덱스를 사용하더라도 PK를 주소처럼 사용하기 때문에 PK인덱스를 한번 더 검색해서 레코드를 읽게 된다.

즉, InnoDB 스토리지엔진에서는 모든 세컨더리 인덱스 검색에서 레코드에 접근하기 위해 반드시 PK B-tree를 다시 한번 검색해야하는 것이다.

> secondary index를 쓸때 pk index b-tree를 한번더 검색하는 것이 성능이 떨어질 것 같지만, 장점도 있다. 자세한 내용은 8.8절 클러스터링 인덱스에서 다룬다.

# 8.3.2 B-Tree 인덱스 키 추가 및 삭제

이걸 잘 알아두면 쿼리의 성능을 쉽게 예측할 수 있다.

+) 인덱스를 사용시 주의사항도 함께 알아보자.

# 8.3.2.1 인덱스 키 추가

우리가 보통 b-tree의 쓰기 작업에 비용이 많이 든다고 하는데, 그 이유는 다음과 같다.

앞서 봤듯, b-tree에 값이 저장될 때는 저장된 키값이 어디에 들어가야할지 적절한 위치를 검색한다.
그 후 위치가 결정되면 b-tree 리프노드에 키값과 레코드 정보를 저장해야하는데
만약 리프노드가 꽉차서 더 저장할 수 없으면 리프노드가 분리돼야하고, 이 때 상위 브랜치 노드까지 처리의 범위가 넓어지기 때문이다.

MyISAM, MEMORY 스토리지 엔진과 달리 InnoDB에서는 새로운 키 값을 b-tree에 즉시 추가하지 않고 지연시켜 나중에 처리 할수 있다. (필요시)
하지만 PK나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 반영해야한다. 자세한 내용은 4.2.10절 체인지 버퍼에서~



### 인덱스 추가로 인한 성능 예측

정확히 얼마나 영향을 받는지는 알 수 없음. 그걸 알려면

- 컬럼 수
- 컬럼 크기
- 인덱스 컬럼

등을 모두 확인해야한다.

**대신, 대략적으로 지연시간을 예측하는 방법은 다음과 같다.**

레코드 추가 작업 비용이 1이라고 하고,
인덱스에 키를 추가하는 작업 비용을 1.5로 계산하는 것이다.

> 테이블에 B-tree 인덱스가 3개 있다면
> 인덱스가 하나도 없는 경우, 레코드만 쓰는 작업 비용이므로 1이라 예측,
> 인덱스가 3개인 경우에는 (1.5*3 + 1) 정도로 예측하는 것이다.

참고로 단위는 지연시간으로, 대부분 디스크로부터 인덱스 페이지를 I/O하는 시간이다. (메모리/cpu 처리 시간은 적음)


## 8.3.2.2 인덱스 키 삭제

B-Tree의 키 값이 삭제되는 경우는 간단하다.

B-Tree의 리프노드를 찾아서 **삭제 마크** 만 하면 작업이 완료된다.
삭제 마킹된 공간은 방치되거나 추후 재활용할 수 있다.

삭제 마킹 작업또한 b-tree 노드에 쓰기 작업을 해야하므로 디스크 io가 필요하다.
따라서, InnoDB를 쓴다면 삭제 마킹 작업도 버퍼링돼 지연될 수 있다.
하지만 특별한 사이드이펙트는 없으므로 걱정 X

## 8.3.2.3 인덱스 키 변경

![240324-010126](/posts/16-mysql.indxe/240324-010126.png)

인덱스 키를 변경하는 것은 리프노드에서 값만 다시 고칠 수 없다.
따라서 다음과 같이 삭제 후 추가를 해야한다.

![240324-010705](/posts/16-mysql.indxe/240324-010705.png)

## 8.3.2.4 인덱스 키 검색

- 인덱스는 select 뿐 아니라, update나 delete를 처리하기 위해서도 사용된다.

### b-tree 인덱스 검색 특징

b-tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.

- 부등호 비교 조건에서도 인덱스 사용 가능
- 하지만 키 값의 뒷부분만 검색하는 용도로는 인덱스 트리를 통한 검색 ❌

#### 함수나 연산으로 변형된 값

- 인덱스 키 값에 변형이 가해진 후에는 B-tree 탐색이 불가. (당연한가?)

이 말은, 함수나 연산을 수행한 결과로 정렬하거나 검색하는 작업은 b-tree의 장점을 이용할 수 없다는 것이다.
이걸 알고 주의하고 쓸 수 있어야한다.

#### innodb 엔진에서의 인덱스 검색

InnoDB 테이블에서는 레코드 잠금 + 넥스트키락이 검색을 수행한 인덱스를 잠근 후
테이블의 레코드를 잠그는 방식으로 구현돼있다.

따라서 udpate나 delete 문장이 실행될 때, 테이블에 적절히 사용할 수 있는 인덱스가 없으면
불필요하게 많은 레코드를 잠근다. 심지어 테이블의 모든 레코드를 잠가버릴 수도 있기 때문에 InnoDB 스토리지 엔진을 쓸 때는
인덱스 설계가 매우 중요하게 생각해야한다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소


