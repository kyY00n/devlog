---
id: 17
title: 8.3 B-Tree 인덱스 (2) - WIP
date: 2024-03-30
tags:
  - Real MySQL
  - B-Tree
  - 인덱스 사용 기준
---

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

스토리지 엔진이 어떻게 인덱스를 경유해서 실제 레코드를 읽어내는지 알아볼 것이다.
-> 어떤 경우에 인덱스를 사용하게 유도할지/사용하지 못하게 할지 판단하기 위해

MySQL이 인덱스를 이용하는 대표적인 방법 세 가지는 다음과 같다.

- 인덱스 레인지 스캔
- 인덱스 풀 스캔
- Loose 인덱스 스캔
- 인덱스 스킵 스캔

### 8.3.4.1 Index Range Scan

- 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 인덱스 접근 방법 가운데 가장 대표적이다!
- 나머지 두 가지 접근 방식보다 빠른 방법
- 한 건만 읽는 경우 - 한 건 이상을 읽는 경우를 구분

#### 예제 - B-Tree 영역 스캔에 필요한 작업

**[그림 1] 인덱스만을 읽는 경우**


```mysql
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

![240330-160250](/posts/17-mysql-index/240330-160250.png)

- 'Ebbe'와 'Gad' 인덱스를 찾아 그 사이 모든 인덱스의 레코드를 읽어 반환한다.
- 루트 노드 -> 브랜치 노드 -> 리프노드 까지 찾아 들어간다. 리프노드까지 가야만 레코드의 시작 지점을 알 수 있다.
- 그림의 두꺼운 선이 스캔해야할 위치 검색을 위한 비교 작업을 의미한다. 


**[그림 2] 데이터파일의 레코드를 읽어와야하는 경우

![240330-160655](/posts/17-mysql-index/240330-160655.png)

B-Tree 인덱스 루트&브랜치 노드를 통해서 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향으로(ASC/DESC) 인덱스를 읽어나가는 과정을 확인할 수 있다.
그림2를 보면 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져오는 것을 알 수 있다.

-> 레인지 스캔의 순서대로 랜덤 디스크 I/O가 일어남.

이는 별도의 정렬 과정이 수반되는 것이 아니라 인덱스 자체의 정렬 특성 때문에 자동으로 그렇게 된다.

#### 인덱스 레인지 스캔의 과정

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 index seek(인덱스 탐색) 라고 한다.
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. 이 과정을 index scan(인덱스 스캔)이라고 한다.
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.

#### Covering index

쿼리가 필요로 하는 데이터가 인덱스만으로도 충족된다면, 실제 데이터를 읽어오는 3번 과정은 생략할 수도 있다.
이를 커버링 인덱스라고 한다. 

쿼리가 **커버링 인덱스로 처리되면**, 레코드를 읽지 않아도 되기 때문에 Random I/O가 상당히 줄어들어 성능이 그만큼 좋아진다.

## 8.3.4.2 Index Full Scan

> 책에서, '인덱스를 사용한다' 라고 표현한 것은 index range scan 이나 loose index scan을 말한거다.
> index full scan 방식 또한 인덱스를 이용하는 것이지만 효율적인 방식은 아니며, 일반적으로 인덱스를 생성하는 목적은 아니다.
> [ChatGPT - 좀 더 자세한 설명](https://chat.openai.com/share/309948a1-4a7c-4fcb-9974-6f258ac7955d)

인덱스 레인지 스캔과 달리 인덱스의 처음부터 끝까지 다 읽는 방식이다.
대표적으로, 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우 풀스캔 방식이 적용된다.
예를 들어, 인덱스는 (A, B, C) 칼럼의 순서로 만들어져 있지만 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우다.

**일반적으로** 인덱스의 크기는 테이블의 크기보다 작으므로 (A, B, C) 인덱스가 있을 때 테이블 풀스캔보다, 인덱스 풀스캔을 쓰는게
효율적일 것이다. 그래서 쿼리 조건이 인덱스에 명시된 칼럼 만으로 처리될 수 있으면 주로 이 방식이 사용된다.

![240330-165334](/posts/17-mysql-index/240330-165334.png)

이 방식은 Index Range Scan 보다는 빠르지 않지만 Table Full Scan 보다는 효율적이다.
테이블 전체를 읽는 것보다는 적은 디스크 I/O로 쿼리를 처리할 수 있다.

## 8.3.4.3 Loose Index Scan

- 생소할 수 있는 개념
- 오라클과 같은 DBMS의 Index Skip Scan 과 비슷하게 동작한다.

